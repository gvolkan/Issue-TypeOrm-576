{"version":3,"sources":["../../src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","file":"SelectQueryBuilder.js","sourcesContent":["import {RawSqlResultsToEntityTransformer} from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {JoinOptions} from \"./JoinOptions\";\nimport {PessimisticLockTransactionRequiredError} from \"./error/PessimisticLockTransactionRequiredError\";\nimport {NoVersionOrUpdateDateColumnError} from \"./error/NoVersionOrUpdateDateColumnError\";\nimport {OptimisticLockVersionMismatchError} from \"./error/OptimisticLockVersionMismatchError\";\nimport {OptimisticLockCanNotBeUsedError} from \"./error/OptimisticLockCanNotBeUsedError\";\nimport {JoinAttribute} from \"./JoinAttribute\";\nimport {RelationIdAttribute} from \"./relation-id/RelationIdAttribute\";\nimport {RelationCountAttribute} from \"./relation-count/RelationCountAttribute\";\nimport {RelationIdLoader} from \"./relation-id/RelationIdLoader\";\nimport {RelationIdLoadResult} from \"./relation-id/RelationIdLoadResult\";\nimport {RelationIdMetadataToAttributeTransformer} from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport {RelationCountLoadResult} from \"./relation-count/RelationCountLoadResult\";\nimport {RelationCountLoader} from \"./relation-count/RelationCountLoader\";\nimport {RelationCountMetadataToAttributeTransformer} from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport {Broadcaster} from \"../subscriber/Broadcaster\";\nimport {QueryBuilder} from \"./QueryBuilder\";\nimport {ReadStream} from \"fs\";\nimport {LockNotSupportedOnGivenDriverError} from \"./error/LockNotSupportedOnGivenDriverError\";\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {SelectQuery} from \"./SelectQuery\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {ObjectType} from \"../common/ObjectType\";\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity> extends QueryBuilder<Entity> {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitOffsetExpression();\n        sql += this.createLockExpression();\n        sql = this.createLimitOffsetOracleSpecificExpression(sql);\n        sql = sql.trim();\n        if (this.expressionMap.subQuery)\n            sql = \"(\" + sql + \")\";\n        return sql;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder();\n        qb.expressionMap.subQuery = true;\n        return qb;\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string|string[], selectionAliasName?: string): this {\n        if (!selection)\n            return this;\n\n        if (selection instanceof Array) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({ selection: selection })));\n        } else {\n            this.expressionMap.selects.push({ selection: selection, aliasName: selectionAliasName });\n        }\n\n        return this;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    from<T>(entityTarget: ObjectType<T>|string, aliasName: string): SelectQueryBuilder<T> {\n        this.setMainAlias(entityTarget, aliasName);\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entity: Function|string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(tableName: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.join(\"INNER\", entityOrProperty, aliasName, condition, options);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entity: Function|string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(tableName: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.join(\"LEFT\", entityOrProperty, aliasName, condition, options);\n        return this;\n    }\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entity: Function|string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(tableName: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(aliasName);\n        this.innerJoin(entityOrProperty, aliasName, condition, options);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entity: Function|string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(tableName: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(aliasName);\n        this.leftJoin(entityOrProperty, aliasName, condition, options);\n        return this;\n    }\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, tableName: string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(aliasName);\n        this.join(\"INNER\", entityOrProperty, aliasName, condition, options, mapToProperty, true);\n        return this;\n    }\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, tableName: string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(aliasName);\n        this.join(\"INNER\", entityOrProperty, aliasName, condition, options, mapToProperty, false);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, tableName: string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(aliasName);\n        this.join(\"LEFT\", entityOrProperty, aliasName, condition, options, mapToProperty, true);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, property: string, aliasName: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, tableName: string, aliasName: string, condition: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(aliasName);\n        this.join(\"LEFT\", entityOrProperty, aliasName, condition, options, mapToProperty, false);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, options: { disableMixedMap: boolean }): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, aliasName: string, queryBuilderFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string,\n                         relationName: string,\n                         aliasNameOrOptions?: string|{ disableMixedMap?: boolean },\n                         queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\n\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n        relationIdAttribute.mapToProperty = mapToProperty;\n        relationIdAttribute.relationName = relationName;\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions;\n        if (aliasNameOrOptions instanceof Object && (aliasNameOrOptions as any).disableMixedMap)\n            relationIdAttribute.disableMixedMap = true;\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(mapToProperty: string, relationName: string, aliasName?: string, queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\n        const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n        relationCountAttribute.mapToProperty = mapToProperty;\n        relationCountAttribute.relationName = relationName;\n        relationCountAttribute.alias = aliasName;\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n\n        this.expressionMap.createAlias({\n            name: relationCountAttribute.junctionAlias\n        });\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                name: relationCountAttribute.junctionAlias,\n                metadata: relationCountAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     */\n    loadAllRelationIds(): this {\n        this.expressionMap.mainAlias!.metadata.relations.forEach(relation => {\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\n                { disableMixedMap: true }\n            );\n        });\n        return this;\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(where: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"simple\", condition: where });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(where: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"and\", condition: where });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(where: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"or\", condition: where });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    whereInIds(ids: any[]): this {\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\n        this.andWhere(whereExpression, parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any[]): this {\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\n        this.andWhere(whereExpression, parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any[]): this {\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\n        this.orWhere(whereExpression, parameters);\n        return this;\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this {\n        this.expressionMap.groupBys = [groupBy];\n        return this;\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy);\n        return this;\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort: string, order?: \"ASC\"|\"DESC\"): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort?: string|OrderByCondition, order: \"ASC\"|\"DESC\" = \"ASC\"): this {\n        if (sort) {\n            if (sort instanceof Object) {\n                this.expressionMap.orderBys = sort as OrderByCondition;\n            } else {\n                this.expressionMap.orderBys = { [sort as string]: order };\n            }\n        } else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(sort: string, order: \"ASC\"|\"DESC\" = \"ASC\"): this {\n        this.expressionMap.orderBys[sort] = order;\n        return this;\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit;\n        return this;\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = offset;\n        return this;\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = take;\n        return this;\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = skip;\n        return this;\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     *\n     * @deprecated use take method instead\n     */\n    setMaxResults(take?: number): this {\n        this.expressionMap.take = take;\n        return this;\n    }\n\n    /**\n     * Sets number of entities to skip.\n     *\n     * @deprecated use skip method instead\n     */\n    setFirstResult(skip?: number): this {\n        this.expressionMap.skip = skip;\n        return this;\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: Date): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"pessimistic_read\"|\"pessimistic_write\"): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\"|\"pessimistic_read\"|\"pessimistic_write\", lockVersion?: number|Date): this {\n        this.expressionMap.lockMode = lockMode;\n        this.expressionMap.lockVersion = lockVersion;\n        return this;\n\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne(): Promise<any> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const results = await this.execute();\n        return results[0];\n\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany(): Promise<any[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        return this.execute();\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities(): Promise<{ entities: Entity[], raw: any[] }> {\n        return this.executeEntitiesAndRawResults({ release: true });\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity|undefined> {\n        const results = await this.getRawAndEntities();\n        const result = results.entities[0] as any;\n\n        if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion = result[metadata.updateDateColumn!.propertyName]; // what if columns arent set?\n                this.expressionMap.lockVersion.setMilliseconds(0);\n                if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n\n            } else {\n                const actualVersion = result[metadata.versionColumn!.propertyName]; // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const results = await this.getRawAndEntities();\n        return results.entities;\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        return this.executeCountQuery({ release: true });\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        try {\n            const result = await Promise.all([\n                this.executeEntitiesAndRawResults({ release: false }),\n                this.executeCountQuery({ release: false })\n            ]);\n            return [result[0].entities, result[1]];\n\n        } finally {\n            if (this.ownQueryRunner) // means we created our own query runner\n                await this.queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        const [sql, parameters] = this.getSqlAndParameters();\n        try {\n            const releaseFn = () => {\n                if (this.ownQueryRunner) // means we created our own query runner\n                    return this.queryRunner.release();\n                return;\n            };\n            return this.queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n\n        } finally {\n            if (this.ownQueryRunner) // means we created our own query runner\n                await this.queryRunner.release();\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(direction: \"INNER\"|\"LEFT\", entityOrProperty: Function|string, aliasName: string, condition?: string, options?: JoinOptions, mapToProperty?: string, isMappingMany?: boolean): void {\n\n        const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n        joinAttribute.direction = direction;\n        joinAttribute.mapToProperty = mapToProperty;\n        joinAttribute.options = options;\n        joinAttribute.isMappingMany = isMappingMany;\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\n        joinAttribute.condition = condition; // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute);\n\n        // todo: find and set metadata right there?\n        joinAttribute.alias = this.expressionMap.createAlias({\n            name: aliasName,\n            metadata: joinAttribute.metadata!\n        });\n        if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                name: joinAttribute.junctionAlias,\n                metadata: joinAttribute.relation.junctionEntityMetadata\n            });\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\"Cannot build query because main alias is not set (call qb#from method)\");\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = [];\n        const excludedSelects: SelectQuery[] = [];\n\n        const aliasName = this.expressionMap.mainAlias.name;\n        const tableName = this.getTableName();\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            allSelects.push(...this.buildEscapedEntityColumnSelects(aliasName, metadata));\n            excludedSelects.push(...this.findEntityColumnSelects(aliasName, metadata));\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes\n            .forEach(join => {\n                if (join.metadata) {\n                    allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name!, join.metadata));\n                    excludedSelects.push(...this.findEntityColumnSelects(join.alias.name!, join.metadata));\n                } else {\n                    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\n                    if (hasMainAlias) {\n                        allSelects.push({ selection: this.escape(join.alias.name!) + \".*\" });\n                        excludedSelects.push({ selection: this.escape(join.alias.name!) });\n                    }\n                }\n            });\n\n        if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === \"class-table\" && metadata.parentIdColumns) {\n                const alias = \"parentIdColumn_\" + metadata.parentEntityMetadata.tableName;\n                metadata.parentEntityMetadata.columns.forEach(column => {\n                    // TODO implement partial select\n                    allSelects.push({ selection: this.escape(alias) + \".\" + this.escape(column.databaseName), aliasName: alias + \"_\" + column.databaseName });\n                });\n            }\n        }\n\n        // add selects from relation id joins\n        // this.relationIdAttributes.forEach(relationIdAttr => {\n        // });\n\n        /*if (this.enableRelationIdValues) {\n         const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);\n         if (!parentMetadata)\n         throw new Error(\"Cannot get entity metadata for the given alias \" + this.aliasMap.mainAlias.name);\n\n         const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);\n         metadata.manyToManyRelations.forEach(relation => {\n\n         const junctionMetadata = relation.junctionEntityMetadata;\n         junctionMetadata.columns.forEach(column => {\n         const select = ea(this.aliasMap.mainAlias.name + \"_\" + junctionMetadata.table.name + \"_ids\") + \".\" +\n         ec(column.name) + \" AS \" +\n         ea(this.aliasMap.mainAlias.name + \"_\" + relation.name + \"_ids_\" + column.name);\n         allSelects.push(select);\n         });\n         });\n         }*/\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter(select => excludedSelects.indexOf(select) === -1)\n            .forEach(select => allSelects.push({ selection: this.replacePropertyNames(select.selection), aliasName: select.aliasName }));\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0)\n            allSelects.push({ selection: \"*\" });\n\n        let lock: string = \"\";\n        if (this.connection.driver instanceof SqlServerDriver) {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    lock = \" WITH (HOLDLOCK, ROWLOCK)\";\n                    break;\n                case \"pessimistic_write\":\n                    lock = \" WITH (UPDLOCK, ROWLOCK)\";\n                    break;\n            }\n        }\n\n        // create a selection query\n        const from = tableName ? this.escape(tableName) : this.expressionMap.mainAlias.subQuery;\n        const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\n        if ((this.expressionMap.limit || this.expressionMap.offset) && this.connection.driver instanceof OracleDriver) {\n            return \"SELECT ROWNUM \" + this.escape(\"RN\") + \",\" + selection + \" FROM \" + from + \" \" + this.escape(aliasName) + lock;\n        }\n        return \"SELECT \" + selection + \" FROM \" + from + \" \" + this.escape(aliasName) + lock;\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n\n            const relation = joinAttr.relation;\n            const destinationTableName = joinAttr.tableName;\n            const destinationTableAlias = joinAttr.alias.name;\n            const appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n            const parentAlias = joinAttr.parentAlias;\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation)\n                return \" \" + joinAttr.direction + \" JOIN \" + this.escape(destinationTableName) + \" \" + this.escape(destinationTableAlias) +\n                    (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns.map(joinColumn => {\n                    return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\n                        parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.escape(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation.inverseRelation!.joinColumns.map(joinColumn => {\n                    return destinationTableAlias + \".\" + relation.inverseRelation!.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\n                        parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.escape(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n\n            } else { // means many-to-many\n                const junctionTableName = relation.junctionEntityMetadata!.tableName;\n\n                const junctionAlias = joinAttr.junctionAlias;\n                let junctionCondition = \"\", destinationCondition = \"\";\n\n                if (relation.isOwning) {\n\n                    junctionCondition = relation.joinColumns.map(joinColumn => {\n                        // `post_category`.`postId` = `post`.`id`\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                    }).join(\" AND \");\n\n                    destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\n                        // `category`.`id` = `post_category`.`categoryId`\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n                    }).join(\" AND \");\n\n                } else {\n                    junctionCondition = relation.inverseRelation!.inverseJoinColumns.map(joinColumn => {\n                        // `post_category`.`categoryId` = `category`.`id`\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                    }).join(\" AND \");\n\n                    destinationCondition = relation.inverseRelation!.joinColumns.map(joinColumn => {\n                        // `post`.`id` = `post_category`.`postId`\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n                    }).join(\" AND \");\n                }\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.escape(junctionTableName) + \" \" + this.escape(junctionAlias) + \" ON \" + this.replacePropertyNames(junctionCondition) +\n                    \" \" + joinAttr.direction + \" JOIN \" + this.escape(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\n\n            }\n        });\n\n        if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias!.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n            if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === \"class-table\" && metadata.parentIdColumns) {\n                const alias = \"parentIdColumn_\" + metadata.parentEntityMetadata.tableName;\n                const condition = metadata.parentIdColumns.map(parentIdColumn => {\n                    return this.expressionMap.mainAlias!.name + \".\" + parentIdColumn.propertyPath + \" = \" + alias + \".\" + parentIdColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n                const join = \" JOIN \" + this.escape(metadata.parentEntityMetadata.tableName) + \" \" + this.escape(alias) + \" ON \" + this.replacePropertyNames(condition);\n                joins.push(join);\n            }\n        }\n\n        return joins.join(\" \");\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n        return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n\n        let orderBys = this.expressionMap.orderBys;\n\n        // if table has a default order then apply it\n        if (!Object.keys(orderBys).length && this.expressionMap.mainAlias!.hasMetadata) {\n            orderBys = this.expressionMap.mainAlias!.metadata.orderBy || {};\n        }\n\n        // if user specified a custom order then apply it\n        if (Object.keys(orderBys).length > 0)\n            return \" ORDER BY \" + Object.keys(orderBys)\n                    .map(columnName => {\n                        return this.replacePropertyNames(columnName) + \" \" + this.expressionMap.orderBys[columnName];\n                    })\n                    .join(\", \");\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query for Oracle database.\n     */\n    protected createLimitOffsetOracleSpecificExpression(sql: string): string {\n        if ((this.expressionMap.offset || this.expressionMap.limit) && this.connection.driver instanceof OracleDriver) {\n            sql = \"SELECT * FROM (\" + sql + \") WHERE \";\n            if (this.expressionMap.offset) {\n                sql += this.escape(\"RN\") + \" >= \" + this.expressionMap.offset;\n            }\n            if (this.expressionMap.limit) {\n                sql += (this.expressionMap.offset ? \" AND \" : \"\") + this.escape(\"RN\") + \" <= \" + ((this.expressionMap.offset || 0) + this.expressionMap.limit);\n            }\n        }\n        return sql;\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        if (this.connection.driver instanceof OracleDriver)\n            return \"\";\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n\n            if (this.expressionMap.limit && this.expressionMap.offset)\n                return \" OFFSET \" + this.expressionMap.offset + \" ROWS FETCH NEXT \" + this.expressionMap.limit + \" ROWS ONLY\";\n            if (this.expressionMap.limit)\n                return \" OFFSET 0 ROWS FETCH NEXT \" + this.expressionMap.limit + \" ROWS ONLY\";\n            if (this.expressionMap.offset)\n                return \" OFFSET \" + this.expressionMap.offset + \" ROWS\";\n\n        } else {\n            if (this.expressionMap.limit && this.expressionMap.offset)\n                return \" LIMIT \" + this.expressionMap.limit + \" OFFSET \" + this.expressionMap.offset;\n            if (this.expressionMap.limit)\n                return \" LIMIT \" + this.expressionMap.limit;\n            if (this.expressionMap.offset)\n                return \" OFFSET \" + this.expressionMap.offset;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (this.connection.driver instanceof MysqlDriver) {\n                    return \" LOCK IN SHARE MODE\";\n\n                } else if (this.connection.driver instanceof PostgresDriver) {\n                    return \" FOR SHARE\";\n\n                } else if (this.connection.driver instanceof SqlServerDriver) {\n                    return \"\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write\":\n                if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE\";\n\n                } else if (this.connection.driver instanceof SqlServerDriver) {\n                    return \"\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n        const conditions = this.expressionMap.havings.map((having, index) => {\n            switch (having.type) {\n                case \"and\":\n                    return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\n                case \"or\":\n                    return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\n                default:\n                    return this.replacePropertyNames(having.condition);\n            }\n        }).join(\" \");\n\n        if (!conditions.length) return \"\";\n        return \" HAVING \" + conditions;\n    }\n\n    protected buildEscapedEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\n\n        const columns: ColumnMetadata[] = hasMainAlias ? metadata.columns : metadata.columns.filter(column => {\n            return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyName);\n        });\n\n        return columns.map(column => {\n            const selection = this.expressionMap.selects.find(select => select.selection === aliasName + \".\" + column.propertyName);\n            return {\n                selection: this.escape(aliasName) + \".\" + this.escape(column.databaseName),\n                aliasName: selection && selection.aliasName ? selection.aliasName : aliasName + \"_\" + column.databaseName,\n                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n            };\n        });\n    }\n\n    protected findEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\n        if (mainSelect)\n            return [mainSelect];\n\n        return this.expressionMap.selects.filter(select => {\n            return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyName);\n        });\n    }\n\n    protected async executeCountQuery(options: { release: boolean }): Promise<number> {\n\n        const mainAlias = this.expressionMap.mainAlias!.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        const distinctAlias = this.escape(mainAlias);\n        let countSql = `COUNT(` + metadata.primaryColumns.map((primaryColumn, index) => {\n                const propertyName = this.escape(primaryColumn.databaseName);\n                if (index === 0) {\n                    return `DISTINCT(${distinctAlias}.${propertyName})`;\n                } else {\n                    return `${distinctAlias}.${propertyName})`;\n                }\n            }).join(\", \") + \") as \\\"cnt\\\"\";\n\n        const [countQuerySql, countQueryParameters] = new SelectQueryBuilder(this)\n            .mergeExpressionMap({ ignoreParentTablesJoins: true })\n            .orderBy()\n            .offset(undefined)\n            .limit(undefined)\n            .select(countSql)\n            .getSqlAndParameters();\n\n        try {\n            const results = await this.queryRunner.query(countQuerySql, countQueryParameters);\n            if (!results || !results[0] || !results[0][\"cnt\"])\n                return 0;\n\n            return parseInt(results[0][\"cnt\"]);\n\n        } finally {\n            if (options.release && this.ownQueryRunner) // means we created our own query runner\n                await this.queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(options: { release: boolean }): Promise<{ entities: Entity[], raw: any[] }> {\n        try { // we wrap everything into try/catch because in any case scenario we must release created connection\n\n            if (!this.expressionMap.mainAlias)\n                throw new Error(`Alias is not set. Use \"from\" method to set an alias.`);\n\n            if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\") && !this.queryRunner.isTransactionActive)\n                throw new PessimisticLockTransactionRequiredError();\n\n            if (this.expressionMap.lockMode === \"optimistic\") {\n                const metadata = this.expressionMap.mainAlias.metadata;\n                if (!metadata.versionColumn && !metadata.updateDateColumn)\n                    throw new NoVersionOrUpdateDateColumnError(metadata.name);\n            }\n\n            const broadcaster = new Broadcaster(this.connection);\n            const relationIdLoader = new RelationIdLoader(this.connection, this.queryRunner, this.expressionMap.relationIdAttributes);\n            const relationCountLoader = new RelationCountLoader(this.connection, this.queryRunner, this.expressionMap.relationCountAttributes);\n            const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n            relationIdMetadataTransformer.transform();\n            const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n            relationCountMetadataTransformer.transform();\n\n            let rawResults: any[] = [], entities: any[] = [];\n\n            // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n            // where we make two queries to find the data we need\n            // first query find ids in skip and take range\n            // and second query loads the actual data in given ids range\n            if (this.expressionMap.skip || this.expressionMap.take) {\n\n                // we are skipping order by here because its not working in subqueries anyway\n                // to make order by working we need to apply it on a distinct query\n                const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n                const metadata = this.expressionMap.mainAlias.metadata;\n                const mainAliasName = this.expressionMap.mainAlias.name;\n\n                const querySelects = metadata.primaryColumns.map(primaryColumn => {\n                    const distinctAlias = this.escape(\"distinctAlias\");\n                    const columnAlias = this.escape(mainAliasName + \"_\" + primaryColumn.propertyName);\n                    if (!orderBys[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction\n                        orderBys[columnAlias] = \"ASC\";\n                    return `${distinctAlias}.${columnAlias} as \"ids_${mainAliasName + \"_\" + primaryColumn.databaseName}\"`;\n                });\n\n                rawResults = await new SelectQueryBuilder(this.connection, this.queryRunner)\n                    .select(`DISTINCT ${querySelects.join(\", \")} `)\n                    .addSelect(selects)\n                    .from(`(${new SelectQueryBuilder(this).orderBy().getQuery()})`, \"distinctAlias\")\n                    .offset(this.expressionMap.skip)\n                    .limit(this.expressionMap.take)\n                    .orderBy(orderBys)\n                    .setParameters(this.getParameters())\n                    .getRawMany();\n\n                if (rawResults.length > 0) {\n                    let condition = \"\";\n                    const parameters: ObjectLiteral = {};\n                    if (metadata.hasMultiplePrimaryKeys) {\n                        condition = rawResults.map(result => {\n                            return metadata.primaryColumns.map(primaryColumn => {\n                                parameters[\"ids_\" + primaryColumn.propertyName] = result[\"ids_\" + primaryColumn.databaseName];\n                                return mainAliasName + \".\" + primaryColumn.propertyName + \"=:ids_\" + primaryColumn.databaseName;\n                            }).join(\" AND \");\n                        }).join(\" OR \");\n                    } else {\n                        const ids = rawResults.map(result => result[\"ids_\" + mainAliasName + \"_\" + metadata.primaryColumns[0].databaseName]);\n                        const areAllNumbers = ids.every((id: any) => typeof id === \"number\");\n                        if (areAllNumbers) {\n                            // fixes #190. if all numbers then its safe to perform query without parameter\n                            condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyName} IN (${ids.join(\", \")})`;\n                        } else {\n                            parameters[\"ids\"] = ids;\n                            condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyName + \" IN (:ids)\";\n                        }\n                    }\n                    rawResults = await new SelectQueryBuilder(this)\n                        .mergeExpressionMap({ extraAppendedAndWhereCondition: condition })\n                        .setParameters(parameters)\n                        .getRawMany();\n                }\n\n            } else {\n                const [sql, parameters] = this.getSqlAndParameters();\n                rawResults = await this.queryRunner.query(sql, parameters);\n            }\n\n            if (rawResults.length > 0) {\n\n                // transform raw results into entities\n                const rawRelationIdResults = await relationIdLoader.load(rawResults);\n                const rawRelationCountResults = await relationCountLoader.load(rawResults);\n                const transformer = new RawSqlResultsToEntityTransformer(this.connection.driver, this.expressionMap.joinAttributes, rawRelationIdResults, rawRelationCountResults);\n                entities = transformer.transform(rawResults, this.expressionMap.mainAlias!);\n\n                // broadcast all \"after load\" events\n                if (this.expressionMap.mainAlias.hasMetadata)\n                    await broadcaster.broadcastLoadEventsForAll(this.expressionMap.mainAlias.target, rawResults);\n            }\n\n            return {\n                raw: rawResults,\n                entities: entities,\n            };\n\n        } finally {\n            if (options.release && this.ownQueryRunner) // means we created our own query runner\n                await this.queryRunner.release();\n        }\n    }\n\n    protected createOrderByCombinedWithSelectExpression(parentAlias: string): [ string, OrderByCondition] {\n\n        // if table has a default order then apply it\n        let orderBys = this.expressionMap.orderBys;\n        if (!Object.keys(orderBys).length && this.expressionMap.mainAlias!.hasMetadata) {\n            orderBys = this.expressionMap.mainAlias!.metadata.orderBy || {};\n        }\n\n        const selectString = Object.keys(orderBys)\n            .map(columnName => {\n                const [alias, column, ...embeddedProperties] = columnName.split(\".\");\n                return this.escape(parentAlias) + \".\" + this.escape(alias + \"_\" + column + embeddedProperties.join(\"_\"));\n            })\n            .join(\", \");\n\n        const orderByObject: OrderByCondition = {};\n        Object.keys(orderBys).forEach(columnName => {\n            const [alias, column, ...embeddedProperties] = columnName.split(\".\");\n            orderByObject[this.escape(parentAlias) + \".\" + this.escape(alias + \"_\" + column + embeddedProperties.join(\"_\"))] = this.expressionMap.orderBys[columnName];\n        });\n\n        return [selectString, orderByObject];\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(expressionMap: Partial<QueryExpressionMap>): this {\n        Object.assign(this.expressionMap, expressionMap);\n        return this;\n    }\n\n}\n"],"sourceRoot":".."}